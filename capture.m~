function [dt_flyby, dv_tot] = capture(rp, delta, parameters, mu, R_atm)
% function [rp,dt_flyby, dv_tot] = capture(ID1,ID2,ID3,R_atm,flyby_date,dep_date,arr_date, parameters, mu)
%PLOT_GA 
%Plot of asymptotes and hyperbolic path in occurrence of the flyby
%
% INPUT
%   - IDx [-] Planets' codes
%   - R_atm [km] Atmospheric upper bound (Constraint)
%   - x_date [days] MJD2000 date of flyby/departure/arrival 
%OUTPUT
%   - rp [km] minimum radius of approach of hyperbolic path (from center)
%   - dt_flyby [hours] TOF across Flyby planet's SOI
%   - dv_tot [km/s] Total deltaV provided by powered g.a. (dv@peric.+ g.a.)
%
%
% Authors : Apeksha Veeranna Roopashree / Sergio Bonnacorsi /
%                     Alberto Chiaradia / Louis Aucouturier
%

%Discretization of hyperbola
n_iter = 1000;

%Computation of the two hyperbolas

e_m = 1/sin(de;

h_m = sqrt(mu*rp*(1+e_m));
h_p = sqrt(mu*rp*(1+e_p));

a_m =((h_m^2)/mu)/(e_m^2-1);
a_p = ((h_p^2)/mu)/(e_p^2-1);

delta_m = 2*asin(1/e_m);
delta_p = 2*asin(1/e_p);
theta_infm = acos(1/e_m);
theta_infp = acos(1/e_p);

%SOI definition
rSOI = nrM * (mu/muS)^(2/5);


correc_m_f = @(alpha) correc_SOI_f(rSOI,alpha,a_m,e_m,theta_infm,mu);
correc_p_f = @(alpha) correc_SOI_f(rSOI,alpha,a_p,e_p,theta_infp,mu);

correc_m = fminsearch(correc_m_f,0);
correc_p = fminsearch(correc_p_f,0);


ltheta_m = linspace(0,theta_infm+correc_m,n_iter);
ltheta_p = linspace(0,-theta_infp-correc_p,n_iter);

lt_m = zeros(1,n_iter);
lt_p = zeros(1,n_iter);

%TOF computation
for i = 1:n_iter
    %eccentric anomalies
    f_m = 2*atanh(sqrt((e_m-1)/(e_m+1))*tan(ltheta_m(i)/2));
    f_p = 2*atanh(sqrt((e_p-1)/(e_p+1))*tan(ltheta_p(i)/2));
    m_m = e_m*sinh(f_m) - f_m;
    m_p = e_p*sinh(f_p) - f_p;
    lt_m(i) = m_m*(h_m^3/mu^2)/((e_m^2-1)^(3/2));
    lt_p(i) = m_p*(h_p^3/mu^2)/((e_p^2-1)^(3/2));
end

%Computation of TOF
dt_m = abs(lt_m(1) - lt_m(n_iter));
dt_p = abs(lt_p(1) - lt_p(n_iter));
dt_flyby = (dt_m+dt_p)/3600;

%Hyperbolas plot
l_pos_Vect_m = zeros(3,n_iter);
l_pos_Vect_p = zeros(3,n_iter);

for i = 1:n_iter
    [r_m,~]= kep2car(a_m,e_m,0,0,0,ltheta_m(i),mu);
    [r_p,~] = kep2car(a_p,e_p,0,0,0,ltheta_p(i),mu);
    l_pos_Vect_m(:,i) = r_m;
    l_pos_Vect_p(:,i) = r_p;
end

figure
axis equal
hold all


[px,py,pz] = sphere(50);    % generate coordinates for a 50 x 50 sphere

cla
mars = surface(py*R_atm, px*R_atm ,flip(pz*R_atm));  
mars.FaceColor = 'y';        % set color to texture mapping
mars.EdgeColor = [1 0.5 0];


r = rSOI;
xc = 0;
yc = 0;

theta = linspace(0,2*pi);
x = r*cos(theta) + xc;
y = r*sin(theta) + yc;

plot(x,y)
plot(l_pos_Vect_m(1,:),l_pos_Vect_m(2,:))
plot(l_pos_Vect_p(1,:),l_pos_Vect_p(2,:))

hold off
end

% Function used to get a correction on the theta for the hyperbola arc to
% reach the Sphere of Influence
function val = correc_SOI_f(rSOI,alpha,a,e,theta,muM)
    [r,~]= kep2car(a,e,0,0,0,theta+alpha,muM);
    val = (norm(r)-rSOI)^2;
end

end

